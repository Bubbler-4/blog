<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust로 새싹문제를 정복해보자 - 1 | Bubbler의 버블로그</title><meta name=keywords content="Rust,PS,Tutorial"><meta name=description content="solved.ac에서는 프로그래밍 언어 입문에 좋은 새싹 문제 리스트를 제공합니다.
이 시리즈에서는 Rust를 가지고 이 문제들을 하나씩 풀어 보겠습니다."><meta name=author content="Bubbler"><link rel=canonical href=https://blog.bubbler.one/posts/tutorial-1/><link crossorigin=anonymous href=/assets/css/stylesheet.9c4f5aa85dab72ee82fc33b8dfb12a3f7459e6c1b389f9fae73095efa3ecb4d6.css integrity="sha256-nE9aqF2rcu6C/DO437EqP3RZ5sGzifn65zCV76PstNY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.bubbler.one/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.bubbler.one/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.bubbler.one/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.bubbler.one/apple-touch-icon.png><link rel=mask-icon href=https://blog.bubbler.one/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://blog.bubbler.one/posts/tutorial-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>@font-face{font-display:swap;font-family:dejavu sans mono;font-style:normal;font-weight:400;src:url(/DejaVuSansMono.woff2)format('woff2'),url(/DejaVuSansMono.woff)format('woff')}code{font-family:dejavu sans mono,monospace}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7RJCHF5L4Z"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7RJCHF5L4Z",{anonymize_ip:!1})}</script><meta property="og:title" content="Rust로 새싹문제를 정복해보자 - 1"><meta property="og:description" content="solved.ac에서는 프로그래밍 언어 입문에 좋은 새싹 문제 리스트를 제공합니다.
이 시리즈에서는 Rust를 가지고 이 문제들을 하나씩 풀어 보겠습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.bubbler.one/posts/tutorial-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-08T22:54:21+09:00"><meta property="article:modified_time" content="2022-09-08T22:54:21+09:00"><meta property="og:site_name" content="Bubbler의 버블로그"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust로 새싹문제를 정복해보자 - 1"><meta name=twitter:description content="solved.ac에서는 프로그래밍 언어 입문에 좋은 새싹 문제 리스트를 제공합니다.
이 시리즈에서는 Rust를 가지고 이 문제들을 하나씩 풀어 보겠습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bubbler.one/posts/"},{"@type":"ListItem","position":2,"name":"Rust로 새싹문제를 정복해보자 - 1","item":"https://blog.bubbler.one/posts/tutorial-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust로 새싹문제를 정복해보자 - 1","name":"Rust로 새싹문제를 정복해보자 - 1","description":"solved.ac에서는 프로그래밍 언어 입문에 좋은 새싹 문제 리스트를 제공합니다. 이 시리즈에서는 Rust를 가지고 이 문제들을 하나씩 풀어 보겠습니다.\n","keywords":["Rust","PS","Tutorial"],"articleBody":"solved.ac에서는 프로그래밍 언어 입문에 좋은 새싹 문제 리스트를 제공합니다. 이 시리즈에서는 Rust를 가지고 이 문제들을 하나씩 풀어 보겠습니다.\n참고: 이 시리즈를 포함한 모든 Rust 관련 포스트는 2021 edition을 기준으로 합니다. BOJ 제출 언어는 Rust 2021입니다.\n시작하기 전에 진심으로 Rust PS에 도전할 예정이라면 The Rust Book 1장을 따라가면서 Rust를 설치하고 PS용 project를 하나 생성해서 사용하는 것이 좋습니다. 링크된 The Rust Book은 Rust의 공식 입문서이니, 이 시리즈를 진행하면서 같이 참고하시면 도움이 될 수 있습니다. (비공식 한글 번역도 있는데, 업데이트가 되지 않은 부분이 일부 있을 수 있습니다.)\n에디터는 개인적으로 VS Code + rust-analyzer 플러그인 조합을 추천합니다.\n일단 Rust의 맛을 조금 보고 결정하려면 Attempt This Online에서 표준 입력과 함께 프로그램을 실행해 볼 수 있습니다.\n출력하기 2557. Hello World! 문제 링크\n클래식한 입문 문제부터 시작해 봅시다.\n먼저, 실행을 위한 코드에는 main 함수가 있어야 합니다. main 함수를 정의하는 문법은 다음과 같습니다.\nfn main() { // 본문 } 출력에는 print!() 또는 println!() 매크로를 사용합니다. “매크로\"라는 단어만 보고 나가떨어지는 분들이 있을 수 있는데, 겁먹을 필요는 전혀 없습니다. C의 printf 내지 Python의 str.format과 비슷한 것이라고 생각해 주시면 됩니다. Rust 함수는 가변 길이의 인자를 받을 수 없기 때문에 함수 대신 매크로를 제공하고 있는 것 뿐입니다.\nHello World!를 출력하려면 다음과 같이 사용합니다.\nfn main() { println!(\"Hello World!\"); } println은 출력 끝에 줄바꿈이 추가되고, print는 추가되지 않습니다. BOJ는 출력 끝의 빈 칸이나 줄바꿈은 무시하고 채점하므로, print와 println 둘 중 어느 것을 써도 정답 처리됩니다.\n25083. 새싹 문제 링크\n조금(?) 더 복잡한 문자열을 출력하는 문제입니다.\n,r'\"7 r`-_ ,' ,/ \\. \". L_r' `~\\/ | | 다른 언어를 써 보셨다면 아시겠지만, 보통 문자열 내에 일부 기호를 넣으려면 escape sequence를 써야 합니다. 줄바꿈은 \\n, \"은 \\\", \\은 \\\\ 처럼 말이죠. 러스트도 마찬가지입니다. (다만 '은 escape할 필요가 없습니다.)\n하지만 러스트는 그 외에도 강력한 raw string 문법을 제공합니다. Python의 그것과 비슷하게 r\"...\"처럼 문자열 앞에 r을 붙이면 raw string이 되어 \" 글자를 제외한 모든 글자를 그대로 문자열 내에 쓸 수 있습니다. \"를 써야 한다면 r#\"...\"#처럼 따옴표 앞뒤에 #를 하나씩 추가해주면 정확히 \"# 문자열이 나올 때까지의 모든 글자를 문자열로 인식합니다. 그걸로도 부족하면 r##\"...\"##처럼 #를 필요한 만큼 추가하면 됩니다.\n이를 이용해서 새싹 문제를 해결하는 코드는 다음과 같습니다. 이 문제는 r\"...\"로는 모자라고 r#\"...\"#를 써야 합니다.\nfn main() { print!(r#\" ,r'\"7 r`-_ ,' ,/ \\. \". L_r' `~\\/ | |\"#); } 문자열의 첫 줄이 뒤틀리는 것은 어쩔 수 없지만, 어쨌든 문제에서 주어진 문자열을 고치지 않고 그대로 복붙해서 풀 수 있습니다.\n연습문제 나머지 “출력” 문제들을 풀어 보세요.\n10699. 오늘 날짜 7287. 등록 10171. 고양이 10172. 개 입력 받기 사실상 Rust PS의 입문 장벽이 시작되는 지점입니다. C의 scanf, C++의 cin, Python의 input에 해당하는 기능이 러스트에는 없다보니, 뭐라도 입력을 받으려면 조금 빙 돌아가야 합니다.\n필요한 기초 기능과 관련 문법에 대한 설명은 Rust Book의 2장(한글, 영어)의 앞부분을 참고하면 도움이 될 것 같습니다.\n11718. 그대로 출력하기 문제 링크\n문제 순서를 바꿔서, 입력을 받아서 아무것도 하지 않아도 되는 문제를 먼저 가져와 봤습니다.\nuse std::io::{stdin, Read}; fn main() { let mut buffer = String::new(); let mut stdin = stdin(); stdin.read_to_string(\u0026mut buffer).unwrap(); print!(\"{}\", buffer); } Rust Book의 예시 코드와 조금 다르게 생겼는데, 달라진 부분만 한 줄씩 설명해 보겠습니다.\nuse std::io::{stdin, Read}; std::io 모듈의 stdin과 Read를 사용하겠다는 선언입니다. stdin() 함수는 Stdin 오브젝트를 반환하며, 이 오브젝트는 Read trait을 구현합니다. 아래에서 쓰게 될 read_to_string이 Read의 메소드 중 하나이기 때문에 Read를 use하지 않으면 컴파일 에러가 납니다. (Rust Book에서 사용한 read_line은 Stdin의 자체 메소드입니다.)\nlet mut stdin = stdin(); stdin()이 주는 Stdin 오브젝트를 stdin이라는 변수에 저장했습니다. 이렇게 선언하면 우변의 stdin은 라이브러리 함수이고, 이 줄의 아래부터 stdin은 지금 선언한 변수를 가리키게 됩니다.\n지금 코드의 경우는 Rust Book에서처럼 stdin()의 결과에 바로 read_to_string 메소드를 호출해도 되지만, 나중에 빠른 입출력을 구현할 때 stdin에 추가적인 처리를 할 예정입니다.\nstdin.read_to_string(\u0026mut buffer).unwrap(); read_line이 stdin에서 한 줄을 읽는 함수라면, read_to_string은 stdin의 내용을 끝까지 읽어 buffer에 저장합니다. read_line과 비슷하게 IO 오류가 발생할 수 있기 때문에 Result가 리턴되는데, 실제로는 오류가 나지 않을 것이라는 것을 컴파일러에게 알려주기 위해 .unwrap()을 추가했습니다. 이 부분이 없으면 unused_must_use라는 경고가 발생합니다.\n이 줄이 지나면 buffer에는 입력된 문자열 전체가 들어 있습니다.\nprint!(\"{}\", buffer); 이를 그대로 출력합니다. print나 println의 첫 번째 인자는 포맷 문자열로, 항상 문자열 상수여야 합니다. 따라서 print!(buffer)와 같은 코드는 컴파일이 되지 않고, buffer가 들어갈 자리를 나타내는 포맷 문자열 \"{}\"을 쓰고 나서 포맷 인자로 buffer를 넘겨줘야 합니다.\nRust 1.65+ 에서의 입력 방법 기존에는 String 버퍼를 먼저 만들고 그 버퍼를 채워야 해서 두 줄의 코드가 필요했는데, Rust 버전 1.65부터는 조금 더 간편하게 입력을 받을 수 있습니다. Read trait의 메소드 read_to_string()과 다르게, std::io::read_to_string 함수는 Read인 오브젝트를 받아서 String 오브젝트를 새로 만들어 반환해 줍니다.\nuse std::io::{stdin, read_to_string}; fn main() { let input = read_to_string(stdin()).unwrap(); print!(\"{}\", input); } 2023년 1월 기준 BOJ와 Codeforces에서 사용 가능합니다.\n입력 파싱하기, 정수 타입, 사칙연산 이제 입력을 가지고 뭔가 계산하려면 문자열을 수로 변환하는 과정을 거쳐야 합니다. Python으로 치면 n, m = map(int, input().split())에서 input()을 제외한 부분에 해당합니다.\n정수 타입과 연산자 러스트도 C나 C++처럼 다양한 크기의 정수 타입을 기본 타입으로 제공합니다. 사용 가능한 모든 정수 타입의 목록은 다음과 같습니다.\n부호가 있는가? 8비트 16비트 32비트 64비트 128비트 register 크기 Yes i8 i16 i32 i64 i128 isize No u8 u16 u32 u64 u128 usize 정수가 아닌 기본 타입은 실수 타입 f32, f64 (각각 float, double에 대응), 글자 타입 char, 참거짓을 나타내는 bool이 있습니다.\nC나 C++의 경우 int나 long 같은 타입의 크기는 환경에 영향을 받는데, 러스트의 정수 타입은 타입 이름에 크기가 모두 쓰여 있어 더 명확합니다. isize와 usize는 요즘 대부분의 컴퓨터가 64비트 프로세서를 쓰기 때문에 64비트라고 가정해도 무방합니다.\n정수형 상수는 1234처럼 그냥 쓰면 컴파일러가 타입 추론을 시도하고, 아무 정수형이나 올 수 있는 상황이면 i32를 사용합니다. 상수에 타입을 주려면 1234u32처럼 뒤에 타입을 붙이면 됩니다. 2진수나 16진수는 0b0011, 0xabcdu32처럼 앞에 0b나 0x를 붙여서 쓸 수 있고, 1_000_000 또는 0b_0001_0111_u32처럼 긴 상수를 읽기 쉽게 _를 구분자로 쓸 수 있습니다. (Rust By Example 참조)\n러스트의 연산자에는 사칙연산 + - * / %, 비교 \u003c = \u003e \u003c= \u003e= !=, 비트 연산 \u0026 | ^ \u003c\u003c \u003e\u003e, 논리 연산 \u0026\u0026 || !, 연산 후 대입 += 등이 있으며, 이들은 모두 C나 C++과 동일하게 동작합니다. 그러나 ++, --는 존재하지 않고, 비트 반전은 ~가 아닌 !를 사용합니다.\n러스트는 안전성을 추구하는 언어이기 때문에, 서로 다른 두 타입의 정수를 가지고 연산하는 것이 금지되어 있습니다. 예를 들어 a: i32와 b: i64를 서로 더하려면 a as i64 + b처럼 명시적 형변환을 해 주어야 합니다. (예외적으로 bitshift 연산은 오른쪽에 아무 정수 타입이 오는 것이 허용됩니다.)\n1000. A+B 문제 링크\n이제 본격적으로 파싱 후 연산을 해 봅시다.\nuse std::io::{stdin, Read}; fn main() { let mut buffer = String::new(); let mut stdin = stdin(); stdin.read_to_string(\u0026mut buffer).unwrap(); let mut words = buffer.split_ascii_whitespace(); let a = words.next().unwrap().parse::\u003cusize\u003e().unwrap(); let b = words.next().unwrap().parse::\u003cusize\u003e().unwrap(); print!(\"{}\", a + b); } main의 앞 3줄까지는 이전 코드와 똑같습니다. 입력을 받았으니 이제 빈 칸을 기준으로 문자열을 나누어야 합니다.\nlet mut words = buffer.split_ascii_whitespace(); 이를 실행해 주는 메소드로는 .split_ascii_whitespace()가 있는데, 정확히는 문자열 조각을 하나씩 내어주는 반복자(Iterator)를 만들어 줍니다. 일단 여기서는 “.next()를 호출해서 물건을 하나씩 여러 번 꺼낼 수 있는 오브젝트\"라고만 생각해도 됩니다. words.next()를 한 번 호출할 때마다 words의 내부 상태가 바뀌기 때문에 words를 mut로 선언합니다.\nlet a = words.next().unwrap().parse::\u003cusize\u003e().unwrap(); let b = words.next().unwrap().parse::\u003cusize\u003e().unwrap(); 여기서 문자열 조각을 하나 꺼내기 위해 words.next()를 호출합니다. 반복자에서 물건 하나를 꺼내는 연산을 했을 때 꺼낼 것이 있을 수도 있고 없을 수도 있어서 Option이 반환되는데, 여기서 문자열을 꺼내기 위해 .unwrap()을 사용합니다. 그 다음, 이 문자열을 정수로 변환하기 위해 .parse()를 사용하는데, 이 함수는 다양한 결과 타입을 줄 수 있기 때문에 어떤 타입을 원하는지 명시적으로 표현해야 합니다. 이 표현을 위한 문법이 ::입니다. 이 변환 역시 실패할 수 있기 때문에 Result가 반환되고, 그 안에 있는 usize를 꺼내기 위해 .unwrap()을 다시 한 번 사용합니다.\n같은 과정을 두 번 사용하여 입력으로 주어지는 두 수 a와 b를 각각 usize 타입으로 얻었습니다.\nprint!(\"{}\", a + b); 마지막으로, 두 수에 대해서 원하는 연산을 수행하여 결과를 출력합니다.\n입력값 하나마다 저렇게 긴 줄을 쳐야 하는 것은 좋지 않기 때문에, 다음 포스트에서 함수 구현을 다루면서 이 부분도 같이 해결할 예정입니다.\n연습문제 나머지 “입력과 계산” 문제들을 풀어 보세요.\n1001. A-B 10998. A×B 10869. 사칙연산 1008. A/B 11382. 꼬마 정민 다음 포스트에서는 함수, 조건문, 반복문을 다뤄보도록 하겠습니다.\n","wordCount":"1269","inLanguage":"ko","datePublished":"2022-09-08T22:54:21+09:00","dateModified":"2022-09-08T22:54:21+09:00","author":{"@type":"Person","name":"Bubbler"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bubbler.one/posts/tutorial-1/"},"publisher":{"@type":"Organization","name":"Bubbler의 버블로그","logo":{"@type":"ImageObject","url":"https://blog.bubbler.one/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bubbler.one/ accesskey=h title="Bubbler의 버블로그 (Alt + H)">Bubbler의 버블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.bubbler.one/en/ title=En aria-label=En>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.bubbler.one/archives title=아카이브><span>아카이브</span></a></li><li><a href=https://blog.bubbler.one/tags title=태그><span>태그</span></a></li><li><a href=https://blog.bubbler.one/search title=검색><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.bubbler.one/>홈</a>&nbsp;»&nbsp;<a href=https://blog.bubbler.one/posts/>Posts</a></div><h1 class=post-title>Rust로 새싹문제를 정복해보자 - 1</h1><div class=post-meta><span title='2022-09-08 22:54:21 +0900 +0900'>2022년 9월 8일</span>&nbsp;·&nbsp;Bubbler</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%8b%9c%ec%9e%91%ed%95%98%ea%b8%b0-%ec%a0%84%ec%97%90 aria-label="시작하기 전에">시작하기 전에</a></li><li><a href=#%ec%b6%9c%eb%a0%a5%ed%95%98%ea%b8%b0 aria-label=출력하기>출력하기</a><ul><li><a href=#2557-hello-world aria-label="2557. Hello World!">2557. Hello World!</a></li><li><a href=#25083-%ec%83%88%ec%8b%b9 aria-label="25083. 새싹">25083. 새싹</a></li><li><a href=#%ec%97%b0%ec%8a%b5%eb%ac%b8%ec%a0%9c aria-label=연습문제>연습문제</a></li></ul></li><li><a href=#%ec%9e%85%eb%a0%a5-%eb%b0%9b%ea%b8%b0 aria-label="입력 받기">입력 받기</a><ul><li><a href=#11718-%ea%b7%b8%eb%8c%80%eb%a1%9c-%ec%b6%9c%eb%a0%a5%ed%95%98%ea%b8%b0 aria-label="11718. 그대로 출력하기">11718. 그대로 출력하기</a></li><li><a href=#rust-165-%ec%97%90%ec%84%9c%ec%9d%98-%ec%9e%85%eb%a0%a5-%eb%b0%a9%eb%b2%95 aria-label="Rust 1.65+ 에서의 입력 방법">Rust 1.65+ 에서의 입력 방법</a></li></ul></li><li><a href=#%ec%9e%85%eb%a0%a5-%ed%8c%8c%ec%8b%b1%ed%95%98%ea%b8%b0-%ec%a0%95%ec%88%98-%ed%83%80%ec%9e%85-%ec%82%ac%ec%b9%99%ec%97%b0%ec%82%b0 aria-label="입력 파싱하기, 정수 타입, 사칙연산">입력 파싱하기, 정수 타입, 사칙연산</a><ul><li><a href=#%ec%a0%95%ec%88%98-%ed%83%80%ec%9e%85%ea%b3%bc-%ec%97%b0%ec%82%b0%ec%9e%90 aria-label="정수 타입과 연산자">정수 타입과 연산자</a></li><li><a href=#1000-ab aria-label="1000. A+B">1000. A+B</a></li><li><a href=#%ec%97%b0%ec%8a%b5%eb%ac%b8%ec%a0%9c-1 aria-label=연습문제>연습문제</a></li></ul></li></ul></div></details></div><div class=post-content><p><a href=https://solved.ac>solved.ac</a>에서는 프로그래밍 언어 입문에 좋은 <a href=https://solved.ac/problems/sprout>새싹 문제 리스트</a>를 제공합니다.
이 시리즈에서는 Rust를 가지고 이 문제들을 하나씩 풀어 보겠습니다.</p><p>참고: 이 시리즈를 포함한 모든 Rust 관련 포스트는 2021 edition을 기준으로 합니다. BOJ 제출 언어는 <code>Rust 2021</code>입니다.</p><h2 id=시작하기-전에>시작하기 전에<a hidden class=anchor aria-hidden=true href=#시작하기-전에>#</a></h2><p>진심으로 Rust PS에 도전할 예정이라면 <a href=https://doc.rust-lang.org/book/ch01-00-getting-started.html>The Rust Book 1장</a>을 따라가면서
Rust를 설치하고 PS용 project를 하나 생성해서 사용하는 것이 좋습니다.
링크된 The Rust Book은 Rust의 공식 입문서이니, 이 시리즈를 진행하면서 같이 참고하시면 도움이 될 수 있습니다.
(<a href=https://rinthel.github.io/rust-lang-book-ko/ch01-00-getting-started.html>비공식 한글 번역</a>도 있는데, 업데이트가 되지 않은 부분이 일부 있을 수 있습니다.)</p><p>에디터는 개인적으로 VS Code + rust-analyzer 플러그인 조합을 추천합니다.</p><p>일단 Rust의 맛을 조금 보고 결정하려면 <a href="https://ato.pxeger.com/run?1=m72kqLS4ZEe0kq5uakpmSWZ-nq2RgZGhko6Ckq6_UuyCpaUlaboWa9PyFHITM_M0NBWquWohYlCpBVAaAA">Attempt This Online</a>에서 표준 입력과 함께 프로그램을 실행해 볼 수 있습니다.</p><h2 id=출력하기>출력하기<a hidden class=anchor aria-hidden=true href=#출력하기>#</a></h2><h3 id=2557-hello-world>2557. Hello World!<a hidden class=anchor aria-hidden=true href=#2557-hello-world>#</a></h3><p><a href=https://boj.kr/2557>문제 링크</a></p><p>클래식한 입문 문제부터 시작해 봅시다.</p><p>먼저, 실행을 위한 코드에는 <code>main</code> 함수가 있어야 합니다. <code>main</code> 함수를 정의하는 문법은 다음과 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 본문
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>출력에는 <code>print!()</code> 또는 <code>println!()</code> 매크로를 사용합니다.
&ldquo;매크로"라는 단어만 보고 나가떨어지는 분들이 있을 수 있는데, 겁먹을 필요는 전혀 없습니다.
C의 <code>printf</code> 내지 Python의 <code>str.format</code>과 비슷한 것이라고 생각해 주시면 됩니다.
Rust 함수는 가변 길이의 인자를 받을 수 없기 때문에 함수 대신 매크로를 제공하고 있는 것 뿐입니다.</p><p><code>Hello World!</code>를 출력하려면 다음과 같이 사용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Hello World!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>println</code>은 출력 끝에 줄바꿈이 추가되고, <code>print</code>는 추가되지 않습니다.
BOJ는 출력 끝의 빈 칸이나 줄바꿈은 무시하고 채점하므로, <code>print</code>와 <code>println</code> 둘 중 어느 것을 써도 정답 처리됩니다.</p><h3 id=25083-새싹>25083. 새싹<a hidden class=anchor aria-hidden=true href=#25083-새싹>#</a></h3><p><a href=https://boj.kr/25083>문제 링크</a></p><p>조금(?) 더 복잡한 문자열을 출력하는 문제입니다.</p><pre tabindex=0><code>         ,r&#39;&#34;7
r`-_   ,&#39;  ,/
 \. &#34;. L_r&#39;
   `~\/
      |
      |
</code></pre><p>다른 언어를 써 보셨다면 아시겠지만, 보통 문자열 내에 일부 기호를 넣으려면 escape sequence를 써야 합니다.
줄바꿈은 <code>\n</code>, <code>"</code>은 <code>\"</code>, <code>\</code>은 <code>\\</code> 처럼 말이죠. 러스트도 마찬가지입니다. (다만 <code>'</code>은 escape할 필요가 없습니다.)</p><p>하지만 러스트는 그 외에도 강력한 raw string 문법을 제공합니다.
Python의 그것과 비슷하게 <code>r"..."</code>처럼 문자열 앞에 <code>r</code>을 붙이면 raw string이 되어 <code>"</code> 글자를 제외한 모든 글자를 그대로 문자열 내에 쓸 수 있습니다.
<code>"</code>를 써야 한다면 <code>r#"..."#</code>처럼 따옴표 앞뒤에 <code>#</code>를 하나씩 추가해주면 정확히 <code>"#</code> 문자열이 나올 때까지의 모든 글자를 문자열로 인식합니다.
그걸로도 부족하면 <code>r##"..."##</code>처럼 <code>#</code>를 필요한 만큼 추가하면 됩니다.</p><p>이를 이용해서 새싹 문제를 해결하는 코드는 다음과 같습니다. 이 문제는 <code>r"..."</code>로는 모자라고 <code>r#"..."#</code>를 써야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print!(<span style=color:#e6db74>r#&#34;         ,r&#39;&#34;7
</span></span></span><span style=display:flex><span><span style=color:#e6db74>r`-_   ,&#39;  ,/
</span></span></span><span style=display:flex><span><span style=color:#e6db74> \. &#34;. L_r&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   `~\/
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      |
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      |&#34;#</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>문자열의 첫 줄이 뒤틀리는 것은 어쩔 수 없지만, 어쨌든 문제에서 주어진 문자열을 고치지 않고 그대로 복붙해서 풀 수 있습니다.</p><h3 id=연습문제>연습문제<a hidden class=anchor aria-hidden=true href=#연습문제>#</a></h3><p>나머지 &ldquo;출력&rdquo; 문제들을 풀어 보세요.</p><ul><li><a href=https://boj.kr/10699>10699. 오늘 날짜</a></li><li><a href=https://boj.kr/7287>7287. 등록</a></li><li><a href=https://boj.kr/10171>10171. 고양이</a></li><li><a href=https://boj.kr/10172>10172. 개</a></li></ul><h2 id=입력-받기>입력 받기<a hidden class=anchor aria-hidden=true href=#입력-받기>#</a></h2><p>사실상 Rust PS의 입문 장벽이 시작되는 지점입니다.
C의 <code>scanf</code>, C++의 <code>cin</code>, Python의 <code>input</code>에 해당하는 기능이 러스트에는 없다보니, 뭐라도 입력을 받으려면 조금 빙 돌아가야 합니다.</p><p>필요한 기초 기능과 관련 문법에 대한 설명은 Rust Book의 2장(<a href=https://rinthel.github.io/rust-lang-book-ko/ch02-00-guessing-game-tutorial.html>한글</a>, <a href=https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html>영어</a>)의 앞부분을 참고하면 도움이 될 것 같습니다.</p><h3 id=11718-그대로-출력하기>11718. 그대로 출력하기<a hidden class=anchor aria-hidden=true href=#11718-그대로-출력하기>#</a></h3><p><a href=https://boj.kr/11718>문제 링크</a></p><p>문제 순서를 바꿔서, 입력을 받아서 아무것도 하지 않아도 되는 문제를 먼저 가져와 봤습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::io::{stdin, Read};
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> buffer <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stdin <span style=color:#f92672>=</span> stdin();
</span></span><span style=display:flex><span>    stdin.read_to_string(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> buffer).unwrap();
</span></span><span style=display:flex><span>    print!(<span style=color:#e6db74>&#34;{}&#34;</span>, buffer);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Rust Book의 예시 코드와 조금 다르게 생겼는데, 달라진 부분만 한 줄씩 설명해 보겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::io::{stdin, Read};
</span></span></code></pre></div><p><code>std::io</code> 모듈의 <code>stdin</code>과 <code>Read</code>를 사용하겠다는 선언입니다.
<a href=https://doc.rust-lang.org/std/io/fn.stdin.html><code>stdin()</code></a> 함수는 <a href=https://doc.rust-lang.org/std/io/struct.Stdin.html><code>Stdin</code></a> 오브젝트를 반환하며,
이 오브젝트는 <a href=https://doc.rust-lang.org/std/io/trait.Read.html><code>Read</code></a> trait을 구현합니다.
아래에서 쓰게 될 <code>read_to_string</code>이 <code>Read</code>의 메소드 중 하나이기 때문에 <code>Read</code>를 use하지 않으면 컴파일 에러가 납니다.
(Rust Book에서 사용한 <code>read_line</code>은 <code>Stdin</code>의 자체 메소드입니다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stdin <span style=color:#f92672>=</span> stdin();
</span></span></code></pre></div><p><code>stdin()</code>이 주는 <code>Stdin</code> 오브젝트를 <code>stdin</code>이라는 변수에 저장했습니다.
이렇게 선언하면 우변의 <code>stdin</code>은 라이브러리 함수이고, 이 줄의 아래부터 <code>stdin</code>은 지금 선언한 변수를 가리키게 됩니다.</p><p>지금 코드의 경우는 Rust Book에서처럼 <code>stdin()</code>의 결과에 바로 <code>read_to_string</code> 메소드를 호출해도 되지만,
나중에 빠른 입출력을 구현할 때 <code>stdin</code>에 추가적인 처리를 할 예정입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    stdin.read_to_string(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> buffer).unwrap();
</span></span></code></pre></div><p><code>read_line</code>이 stdin에서 한 줄을 읽는 함수라면, <code>read_to_string</code>은 stdin의 내용을 끝까지 읽어 <code>buffer</code>에 저장합니다.
<code>read_line</code>과 비슷하게 IO 오류가 발생할 수 있기 때문에 <code>Result</code>가 리턴되는데,
실제로는 오류가 나지 않을 것이라는 것을 컴파일러에게 알려주기 위해 <code>.unwrap()</code>을 추가했습니다.
이 부분이 없으면 <code>unused_must_use</code>라는 경고가 발생합니다.</p><p>이 줄이 지나면 <code>buffer</code>에는 입력된 문자열 전체가 들어 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    print!(<span style=color:#e6db74>&#34;{}&#34;</span>, buffer);
</span></span></code></pre></div><p>이를 그대로 출력합니다. <code>print</code>나 <code>println</code>의 첫 번째 인자는 포맷 문자열로, 항상 문자열 <strong>상수</strong>여야 합니다.
따라서 <code>print!(buffer)</code>와 같은 코드는 컴파일이 되지 않고, <code>buffer</code>가 들어갈 자리를 나타내는 포맷 문자열 <code>"{}"</code>을 쓰고 나서
포맷 인자로 <code>buffer</code>를 넘겨줘야 합니다.</p><h3 id=rust-165-에서의-입력-방법>Rust 1.65+ 에서의 입력 방법<a hidden class=anchor aria-hidden=true href=#rust-165-에서의-입력-방법>#</a></h3><p>기존에는 <code>String</code> 버퍼를 먼저 만들고 그 버퍼를 채워야 해서 두 줄의 코드가 필요했는데,
Rust 버전 1.65부터는 조금 더 간편하게 입력을 받을 수 있습니다.
<code>Read</code> trait의 메소드 <code>read_to_string()</code>과 다르게, <code>std::io::read_to_string</code> 함수는 <code>Read</code>인 오브젝트를 받아서
<code>String</code> 오브젝트를 새로 만들어 반환해 줍니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::io::{stdin, read_to_string};
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> read_to_string(stdin()).unwrap();
</span></span><span style=display:flex><span>    print!(<span style=color:#e6db74>&#34;{}&#34;</span>, input);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2023년 1월 기준 BOJ와 Codeforces에서 사용 가능합니다.</p><h2 id=입력-파싱하기-정수-타입-사칙연산>입력 파싱하기, 정수 타입, 사칙연산<a hidden class=anchor aria-hidden=true href=#입력-파싱하기-정수-타입-사칙연산>#</a></h2><p>이제 입력을 가지고 뭔가 계산하려면 문자열을 수로 변환하는 과정을 거쳐야 합니다.
Python으로 치면 <code>n, m = map(int, input().split())</code>에서 <code>input()</code>을 제외한 부분에 해당합니다.</p><h3 id=정수-타입과-연산자>정수 타입과 연산자<a hidden class=anchor aria-hidden=true href=#정수-타입과-연산자>#</a></h3><p>러스트도 C나 C++처럼 다양한 크기의 정수 타입을 기본 타입으로 제공합니다. 사용 가능한 모든 정수 타입의 목록은 다음과 같습니다.</p><table><thead><tr><th style=text-align:center>부호가 있는가?</th><th style=text-align:center>8비트</th><th style=text-align:center>16비트</th><th style=text-align:center>32비트</th><th style=text-align:center>64비트</th><th style=text-align:center>128비트</th><th style=text-align:center>register 크기</th></tr></thead><tbody><tr><td style=text-align:center>Yes</td><td style=text-align:center><code>i8</code></td><td style=text-align:center><code>i16</code></td><td style=text-align:center><code>i32</code></td><td style=text-align:center><code>i64</code></td><td style=text-align:center><code>i128</code></td><td style=text-align:center><code>isize</code></td></tr><tr><td style=text-align:center>No</td><td style=text-align:center><code>u8</code></td><td style=text-align:center><code>u16</code></td><td style=text-align:center><code>u32</code></td><td style=text-align:center><code>u64</code></td><td style=text-align:center><code>u128</code></td><td style=text-align:center><code>usize</code></td></tr></tbody></table><p>정수가 아닌 기본 타입은 실수 타입 <code>f32</code>, <code>f64</code> (각각 <code>float</code>, <code>double</code>에 대응), 글자 타입 <code>char</code>, 참거짓을 나타내는 <code>bool</code>이 있습니다.</p><p>C나 C++의 경우 <code>int</code>나 <code>long</code> 같은 타입의 크기는 환경에 영향을 받는데, 러스트의 정수 타입은 타입 이름에 크기가 모두 쓰여 있어 더 명확합니다.
<code>isize</code>와 <code>usize</code>는 요즘 대부분의 컴퓨터가 64비트 프로세서를 쓰기 때문에 64비트라고 가정해도 무방합니다.</p><p>정수형 상수는 <code>1234</code>처럼 그냥 쓰면 컴파일러가 타입 추론을 시도하고, 아무 정수형이나 올 수 있는 상황이면 <code>i32</code>를 사용합니다.
상수에 타입을 주려면 <code>1234u32</code>처럼 뒤에 타입을 붙이면 됩니다.
2진수나 16진수는 <code>0b0011</code>, <code>0xabcdu32</code>처럼 앞에 <code>0b</code>나 <code>0x</code>를 붙여서 쓸 수 있고,
<code>1_000_000</code> 또는 <code>0b_0001_0111_u32</code>처럼 긴 상수를 읽기 쉽게 <code>_</code>를 구분자로 쓸 수 있습니다.
(<a href=https://doc.rust-lang.org/rust-by-example/primitives/literals.html>Rust By Example</a> 참조)</p><p>러스트의 연산자에는 사칙연산 <code>+ - * / %</code>, 비교 <code>&lt; = > &lt;= >= !=</code>, 비트 연산 <code>& | ^ &lt;&lt; >></code>, 논리 연산 <code>&& || !</code>, 연산 후 대입 <code>+=</code> 등이 있으며,
이들은 모두 C나 C++과 동일하게 동작합니다. 그러나 <code>++</code>, <code>--</code>는 존재하지 않고, 비트 반전은 <code>~</code>가 아닌 <code>!</code>를 사용합니다.</p><p>러스트는 안전성을 추구하는 언어이기 때문에, 서로 다른 두 타입의 정수를 가지고 연산하는 것이 금지되어 있습니다.
예를 들어 <code>a: i32</code>와 <code>b: i64</code>를 서로 더하려면 <code>a as i64 + b</code>처럼 명시적 형변환을 해 주어야 합니다.
(예외적으로 bitshift 연산은 오른쪽에 아무 정수 타입이 오는 것이 허용됩니다.)</p><h3 id=1000-ab>1000. A+B<a hidden class=anchor aria-hidden=true href=#1000-ab>#</a></h3><p><a href=https://boj.kr/1000>문제 링크</a></p><p>이제 본격적으로 파싱 후 연산을 해 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::io::{stdin, Read};
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> buffer <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stdin <span style=color:#f92672>=</span> stdin();
</span></span><span style=display:flex><span>    stdin.read_to_string(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> buffer).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> words <span style=color:#f92672>=</span> buffer.split_ascii_whitespace();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> words.next().unwrap().parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> words.next().unwrap().parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap();
</span></span><span style=display:flex><span>    print!(<span style=color:#e6db74>&#34;{}&#34;</span>, a <span style=color:#f92672>+</span> b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>main</code>의 앞 3줄까지는 이전 코드와 똑같습니다. 입력을 받았으니 이제 빈 칸을 기준으로 문자열을 나누어야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> words <span style=color:#f92672>=</span> buffer.split_ascii_whitespace();
</span></span></code></pre></div><p>이를 실행해 주는 메소드로는 <code>.split_ascii_whitespace()</code>가 있는데, 정확히는 문자열 조각을 하나씩 내어주는 반복자(<a href=https://doc.rust-lang.org/std/iter/trait.Iterator.html><code>Iterator</code></a>)를 만들어 줍니다. 일단 여기서는 &ldquo;<code>.next()</code>를 호출해서 물건을 하나씩 여러 번 꺼낼 수 있는 오브젝트"라고만 생각해도 됩니다.
<code>words.next()</code>를 한 번 호출할 때마다 <code>words</code>의 내부 상태가 바뀌기 때문에 <code>words</code>를 <code>mut</code>로 선언합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> words.next().unwrap().parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> words.next().unwrap().parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>().unwrap();
</span></span></code></pre></div><p>여기서 문자열 조각을 하나 꺼내기 위해 <code>words.next()</code>를 호출합니다.
반복자에서 물건 하나를 꺼내는 연산을 했을 때 꺼낼 것이 있을 수도 있고 없을 수도 있어서 <code>Option</code>이 반환되는데, 여기서 문자열을 꺼내기 위해 <code>.unwrap()</code>을 사용합니다.
그 다음, 이 문자열을 정수로 변환하기 위해 <code>.parse()</code>를 사용하는데, 이 함수는 다양한 결과 타입을 줄 수 있기 때문에 어떤 타입을 원하는지 명시적으로 표현해야 합니다. 이 표현을 위한 문법이 <code>::&lt;usize></code>입니다. 이 변환 역시 실패할 수 있기 때문에 <code>Result</code>가 반환되고, 그 안에 있는 <code>usize</code>를 꺼내기 위해 <code>.unwrap()</code>을 다시 한 번 사용합니다.</p><p>같은 과정을 두 번 사용하여 입력으로 주어지는 두 수 <code>a</code>와 <code>b</code>를 각각 <code>usize</code> 타입으로 얻었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    print!(<span style=color:#e6db74>&#34;{}&#34;</span>, a <span style=color:#f92672>+</span> b);
</span></span></code></pre></div><p>마지막으로, 두 수에 대해서 원하는 연산을 수행하여 결과를 출력합니다.</p><p>입력값 하나마다 저렇게 긴 줄을 쳐야 하는 것은 좋지 않기 때문에, 다음 포스트에서 함수 구현을 다루면서 이 부분도 같이 해결할 예정입니다.</p><h3 id=연습문제-1>연습문제<a hidden class=anchor aria-hidden=true href=#연습문제-1>#</a></h3><p>나머지 &ldquo;입력과 계산&rdquo; 문제들을 풀어 보세요.</p><ul><li><a href=https://boj.kr/1001>1001. A-B</a></li><li><a href=https://boj.kr/10998>10998. A×B</a></li><li><a href=https://boj.kr/10869>10869. 사칙연산</a></li><li><a href=https://boj.kr/1008>1008. A/B</a></li><li><a href=https://boj.kr/11382>11382. 꼬마 정민</a></li></ul><p>다음 포스트에서는 함수, 조건문, 반복문을 다뤄보도록 하겠습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bubbler.one/tags/rust/>Rust</a></li><li><a href=https://blog.bubbler.one/tags/ps/>PS</a></li><li><a href=https://blog.bubbler.one/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=prev href=https://blog.bubbler.one/posts/chocolate1/editorial/><span class=title>« 이전 페이지</span><br><span>제1회 초콜릿컵 에디토리얼</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Bubbler-4/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.bubbler.one/>Bubbler의 버블로그</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>